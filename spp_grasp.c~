/* spp_grasp.c
 * Authors : DELAVERNHE Florian, LEGRU Guillaume
 * Date : 17th of Nov. 2015
 *
 * Implementation of GRASP metaheuristic applied to SPP.
 *
 * use : argv[0] datafile alpha
 */






/* TODO relire bien la matrix*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>

typedef struct
{
	int nbctr;
	int nbvar;
	int** matrix;
	int* coef;
} data;

int readfile(data* dat, char* datafile)
{
	FILE *fin;
	int val; 
	int i,j,k;
	int ctrSize;
	
	fin = fopen(datafile, "r");

	//nbctr nbvar
	fscanf(fin, "%d", &val);
	dat->nbctr = val;
	fscanf(fin, "%d", &val);
	dat->nbvar = val;

	dat->coef = (int *) malloc (dat->nbvar * sizeof(int));
	for (i = 0; i < dat->nbvar; ++i)
	{
		fscanf(fin, "%d", &val);
		dat->coef[i] = val;
	}

	dat->matrix = (int **) malloc (dat->nbctr * sizeof(int*));
	for (i = 0; i < dat->nbctr; ++i)
	{
		dat->matrix[i] = (int *) malloc (dat->nbvar * sizeof(int));
		for (k = 0; k < dat->nbvar; ++k)
		{
			dat->matrix[i][k] = 0;
		}
		
		fscanf(fin, "%d", &ctrSize);
		for (j=0; j < ctrSize; ++j)
		{
			fscanf(fin, "%d", &val);
			dat->matrix[i][j] = (j == val) ? 1 : 0;
		}
	}
	return 1; 
}

void setUtility(double* utility, data* dat, int* fixVar, int*actCtr)
{
	int k;
	int i,j;	
	for (j = 0; j < dat->nbvar; ++j)
	{
		k = 0;

		if(!fixVar[j])
		{
			for (i = 0; i < dat->nbctr; ++i)
			{
				if (actCtr[i])
				{
					k += dat->matrix[i][j];
				}
			}
			utility[j] = (k == 0) ?  9999 : (double) dat->coef[j] / (double) k;
		}
		else
		{
			utility[j] = 0;
		}
	}
}

const int allDisabled(const int* actCtr, const data* dat)
{
	int res = 1;
	int i;
	for (i = 0; i < dat->nbctr; ++i)
	{
		if(actCtr[i])
		{
			res = 0;
		}
	}
	return res;
}

void display (const int* sol, const int size)
{
	int i;
	for (i = 0; i < size; i++)
	{
		printf("%d ", sol[i]);
	}
	printf("\n");
}

int main (int argc, char** argv)
{
	data dat;
	double* utility;
	int* fixVar;
	int* actCtr;
	int* sol;
	double Umax, bound;
	double alpha;
	int* aux;
	int choice;
	
	int i,j;
	int cpt;
	
	printf("Vérification du nombre d'argument ... \n");
	
	if (argc != 3)
	{
		printf("error : usage : %s <datafile> <alpha>\n", argv[0]);
		exit(1);
	}

	printf("OK!\n");
	
	alpha = atof(argv[2]);

	printf("Lecture du fichier de données... \n"); 
	if (readfile(&dat, argv[1]))
	{
		for (i = 0; i < dat.nbctr; i++)
		{
			for (j = 0; j < dat.nbvar; j++)
			{
				printf(" %d", dat.matrix[i][j]);
			}
			printf("\n");
		}

		exit(0);
		
		printf("OK!\n");
		printf("Allocation mémoire...\n");
		
		sol = (int*) malloc (dat.nbvar* sizeof(int));
		fixVar = (int*) malloc (dat.nbvar* sizeof(int));
		actCtr = (int*) malloc (dat.nbctr* sizeof(int));
		utility = (double *) malloc (dat.nbvar * sizeof(double));

		for (i = 0; i < dat.nbctr; ++i)
		{
			actCtr[i] = 1;
		}

		for (j = 0; j < dat.nbvar; ++j)
		{
			fixVar[j] = 0;
		}
		
		for (j = 0; j < dat.nbvar; ++j)
		{
			sol[j] = 0;
		}

		printf("OK!\n");
		printf("Construction d'une solution initiale ...\n");
		
		while (!allDisabled(actCtr, &dat))
		{
			printf("Calcul des utilitées ...\n");
			setUtility(utility, &dat, fixVar, actCtr);
			printf("Utilitées : ");
			for (j = 0; j < dat.nbvar; j++)
			{
				printf("%f ", utility[j]);
			}
			printf(" ... OK!\n");

			
			printf("Calcul de Umax ...\n");
			Umax = -1;
			for (j = 0; j < dat.nbvar; ++j)
			{
				if ( utility[j] > Umax)
				{
					Umax  = utility[j];
				}
			}
			printf("OK : Umax = %f!\n", Umax);
			assert (Umax != -1); 

			printf("Determination des candidats en fonction de Umax et de alpha ...\n");
			bound = Umax * alpha;
			aux = (int *) malloc (dat.nbvar*sizeof(int)); 
			cpt = 0;
			for (j = 0; j < dat.nbvar; ++j)
			{
				if(utility[j] >= bound)
				{
					aux[cpt] = j;
					++cpt;
				}
			}
			printf("OK : Seuil  = %f pour un Umax de %f\n", bound, Umax);

			srand((unsigned int) time(0));
			choice  = rand() % cpt;
			printf("Choix aléatoire de la valaur fixé : %d d'utilité %f\n", choice, utility[choice]);

			sol[choice] = 1;
			fixVar[choice] = 1;

			for (i = 0; i < dat.nbctr; ++i)
			{
				if (dat.matrix[i][choice])
				{
					actCtr[i] = 0;
				}
			}
		}
		printf("Solution initiale : OK!\n");
		display(sol, dat.nbvar);
	}
	else
	{
		printf("impossible to read : wrong data file !");
		exit(1);
	}

	return 0;
}
